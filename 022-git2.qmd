# Clonage, pull, push et branches


## Création d'un dépôt git et son clonage

Une fois la connection entre RStudio et une plateforme établie: 

* Les opérations se feront toujours dans un projet.
* La méthode la plus employées est la création du dépôt à distance, il est toutefois possible de tout réaliser via R (package usethis) si on est sur la plateforme Github


### Création d'un dépôt distant {#sec-glproj} 

::: {.panel-tabset}

### Gitlab

* Se mettre sur **homepage** si nécessaire en cliquant sur l'icone gitlab {{< fa brands gitlab>}} (en haut à gauche)
* Cliquer sur **New Project**
  * ***Create blank project*** [pour ce chapitre]
  * ***Create from template*** [pour le chapitre suivant] 
  
#### Création d'un dépôt sans utiliser de template   

:::{.center}
:::{.box_img}
![](img2/img1.png){width=75%}
:::
:::


* Par défaut: le dépôt est en mode **private**. Il n'est visible que par les personnes collaborant au projet.
  * Saisir un nom de dépôt.
  * Option de l'url: 
    * On peut choisir son nom d'avatar après `https://gitlab.com/`
    * Par défaut le dossier final est le nom du dépôt saisi. On peut le changer.
  * Private/Public: 
    * Par défaut **private**. On peut le passer en mode **public**.
    * On pourra changer ce mode  dans les paramètres du projet [voir plus loin].
  * Garder la création d'un fichier **README.md**.

::: {.center} 
:::{.box_img} 
![](img2/img2.png){width=75%}
:::
:::


::: {.center}
:::{.box_img}
![](img2/video1.gif){width=75%}
:::
:::


#### Changer la visibilité et supprimer un projet

* Aller dans la barre verticale à gauche: **Setting** {{< fa solid arrow-right >}} **General**

* Visibilité:  Passer de public à private et inversement: 
    * Cliquer sur **expand** **Visibility, project features, permissions** {{< fa solid arrow-right >}} **Project visibility **.
    
* Supprimer un dépôt: Tout en bas de la page aller sur **Advanced**.  

::: {.center}
::: {.box_img}  
![](img2/video2.gif){width=75%}
:::
:::

::: callout-important

#### Fichier .gitignore

Ce fichier est important. A la création du dépôt distant, il n'est pas généré. Pas de soucis, avec Rstudio il sera automatiquement ajouté à votre répertoire local lors de la création du projet, avec déjà certains fichiers exclus des transferts (.Rproj.user, .Rhistory, .RData, .Ruserdata). 
:::

  
### Github 

* Sur la page du profil, aller sur **Repositories** et cliquer sur **New**.
* Donner un nom au répertoire.
* Sélectionner le type de visibilité (par défaut **Public**). On pourra changer à souhait de visibilité dans les paramètres du dépôt (Settings).
* Sélectionner l'ajout un fichier README.md.
* Vous pouvez ajouter un fichier .gitignore (dont un avec un template R), mais celui ci sera généré automatiquement avec la création du projet sous RStudio.

::: {.center} 
::: {.box_img} 
![](img2/video3.gif){width=75%}
:::
:::

:::


## Clonage d'un dépôt distant dans RStudio

* Les manipulations sont strictement identiques avec Gitlab et Github.
* Le clonage du répertoire distant dans Rstudio se fera ici via protocole HTTPS.

Les étapes:

### Dans le répertoire distant

* Dans le dépôt cliquer sur l'icône **Code** {{< fa solid turn-down >}}
* Copier le lien du dépôt (ici via https).

::: {.center} 
::: {.box_img} 
![](img2/img3.png){width=75%}
:::
::: 


### En local dans RStudio

* Créer un nouveau projet: File {{< fa solid arrow-right >}} New project 

* Sélectionner **Version control** {{< fa solid turn-down >}}

* Git {{< fa solid turn-down >}}

* Coller le lien récupéré dans le dépôt {{< fa solid turn-down >}}

* Sélectionner un répertoire pour le projet  {{< fa solid turn-down >}}

* Créer le projet

:::: {layout="[30,-1.5,30,-1.5,30]" layout-valign="bottom" }

::: {.box_img}
![](img2/img4.png){group="rs1"}
:::

::: {.box_img}
![](img2/img5.png){group="rs1"}
:::

::: {.box_img}
![](img2/img6.png){group="rs1"}
:::
::::

::: {layout="[30,-1.5,30,-1.5,30]"}
::: {.box_img}
![](img2/img7.png){group="rs1"}
:::

::: {.box_img}
![](img2/img8.png){group="rs1"}
:::

::: {.box_img}
![](img2/img9.png){group="rs1"}
:::

::::


Lorsque le projet a été créé après clonage du dépôt distant:

Un onglet Git apparait dans l'environnement: 

* Un menu permet d'effectuer directement des opérations de versionnage et de transferts de fichiers.

* Des fichiers sont affichés:
  * Les  fichiers  générés à la création du projet comme *.gitignore* et ici *test_support.Rproj*. Ce sont donc des nouveaux éléments par rapport au dépot distant. 
* Des fichiers ne sont pas affichés:   
  * Le fichier *README.md* généré lors de la création du dépôt distant puis cloné sur le répertoire local. 
  * Les fichiers renseignés automatiquement dans le fichier .gitignore: *.Rproj.user*, *.Rhistory*, *.RData*, *.Ruserdata*.

* On peut toujours visualiser l'ensemble des fichiers du projet sont dans la fenêtre *Files*. 

* Dans le terminal (bash):
  * Le répertoire est calé sur la racine du projet. 
  * La branche de destination est indiquée entre parenthèses, `main` ou `(master)`.

A ce stade, on peut déjà mettre à jour le répertoire distant avec les éléments générés lors de la création du projet.


::: {.callout-tip collapse=TRUE}

#### Générer un projet et créé un dépot sur Github à partir de R avec le package `usethis`

A faire peut être sous forme de fiche pour ne pas alourdir ce support. Avec trois fonctions du package `usethis`, on peut générer relativement rapidement un dépôt github associé à un projet tout en restant sur la console R.  

Rapidement les différentes étapes:  

* Installation et chargement du package `usethis`.
* Création d'un projet R:  fonction `create_project()`.
* Création d'une instance git dans le projet: `use_git()`.
* Création d'un dépôt distant sur github:  `use_github()`.

Prévoir la création de deux sessions RStudio lors de ces étapes.

:::

## Les principales opérations git pour transférer des fichiers


::: callout-important

Encore une fois, on reste ici sur un objectif de déploiement d'une documentation. Les commandes `git status`, `git add` ou `git commit` sont avant tout des opérations permettant d'effectuer le versionnage du projet: la première pour vérifier le statut des fichiers (modification, création, suppression), la seconde pour sélectionner des fichiers à versionner, et la troisième pour figer un état du projet. 


Pour des raisons pédagogiques on privilégiera dans un premier temps l'exécution par clic bouton dans la fenêtre git de Rstudio. Néanmoins, on peut conseiller de passer directement par les commandes, par défaut très simple, via le terminal. 

:::


### Statut et séléction des fichiers

Dans l'onglet **Git** on peut sélectionner les fichiers qui vont être transférés sur le dépôt distant en les cochant (colonne **Staged**). Leur statut passe de **?** (jaune) à **A** (Added).

Remarque: le statut des fichiers peut être visualisé dans le terminal avec la commande **`git status`**. Cette commande ne réalise aucune opération.

::: {.center} 
::: {.box_img} 
![](img2/img10.png){width=75%}
::: 
::: 


S'il y a beaucoup de fichiers^[Dans un projet Quarto de type website c'est le cas lorsqu'on réalise une compilation d'ensemble], il est préférable de passer directement par la ligne de commande dans le terminal, surtout si on souhaite sélectionner l'ensemble.

Dans le terminal, pour sélectionner et ajouter un ou plusieurs fichiers au versionnage:

```{.bash filename="Ajout d'un fichier"}
git add nom_fichier
```


```{.bash filename="Ajout de tous les éléments modifiés"}
git add .
```



### Fixer un état de la chronologie du projet: commit 
  
* Dans l'onglet GIT: cliquer sur **Commit** . 
  * On remarque que le contenu texte des fichiers est affiché. Ici tout est en fond vert car ce sont des nouveaux fichiers et non des modifications de fichiers existants.
  * On doit obligatoire renseigner l'objet de ce *commit* dans la fenêtre **Commit message**: par exemple ici "*First add*". On valide avec bouton **Commit**.
  

:::: {layout="[30,-1.5,30,-1.5,30]" layout-valign="bottom"}
::: {.box_img}
![](img2/img11.png){group="rs2"} 
::: 
::: {.box_img}
![](img2/img12.png){group="rs2"}   
:::
::: {.box_img}
![](img2/img13.png){group="rs2"}  
:::
::::


* Commande du terminal:
  
```{.bash filename="Syntaxe de la commande commit" }  
git commit -m "message/titre"
```    


### Transférer les fichiers du local au distant: push

Pour effectuer ce transfert on fait un **PUSH**.

Fèche montante dans la fenêtre git ou dans la fenêtre commit.

::::: {.column width="75%"}
:::: {layout="[40,-2,40,]"  layout-valign="bottom"}
::: {.box_img}
![](img2/img14.png){group="rs3"}  
:::
::: {.box_img}
![](img2/img15.png){group="rs3"}   
:::
::::
:::::


Dans le terminal: 

```{.bash filename="Transférer les fichiers"}
git push
```



En résumé le transfert peut être effectué rapidement dans le terminal avec 3 commandes, `git status` n'ayant qu'une visée informative. Si on sélectionne tous les fichiers modifié depuis le précédents commit:

```{.bash}
git add .
git commit --m "objet/titre"
git push
```


Sur le répertoire distant, ici sur Gitlab, les deux fichiers ont bien été ajoutés.

::: {.center}  
::: {.box_img}
![](img2/img16.png){width=75%}
:::
:::

### Du distant au local: pull

Hors travail via des branches secondaires qui seront fusionnées avec la branche principale, il n'est pas conseillé de modifier directement les fichiers du projet dans répertoire distant. Si c'est le cas^[Classique pour les fichiers Readme.md], il ne sera pas possible de faire remonter directement avec un **PUSH** le local vers le distant. Il faudra au préalable une synchronisation descendante du distant vers le local. Cette opération est réalisée avec un **PULL**. 

::: callout-warning
S'il n'est pas conseillé d'éditer un fichier manuellement sur le distant, ça l'est est encore moins de modifier sans synchronisation préalable un même fichier sur le local **et** le distant à partir d'une même version du projet. Sinon cela sera un passage assuré vers la case [**CONFLICT**]{style="color:#e74c3c"}... et il faudra choisir entre les deux versions modifiées.
:::

Exemple en modifiant le fichier README.md dans le dépôt distant (gitlab).

* Dans le dépôt distant, aller sur le fichier README.md {{< fa solid turn-down >}}
* Cliquer sur le bouton **edit** {{< fa solid turn-down >}}
* Sur Gitlab préférer l'option **Edit a single file** {{< fa solid turn-down >}}
* On versionne avec le bouton **Commit change** en bas  (ici *Update Readme.md*, mais on peut changer le titre du commit).  


:::: {layout="[30,30,30,]"  layout-valign="bottom"}
::: {.box_img}
![](img2/img17.png){group="gl1"}   
:::
::: {.box_img}
![](img2/img18.png){group="gl1"}
:::
::: {.box_img}
![](img2/img19.png){group="gl1"}
:::
::::

De retour sur le répertoire local, si on veut  **PUSHER** des modifications locales (hors fichier Readme.md), l'opération sera rejetée. Il faut donc que les modifications apportées aux dépôt distant soient récupérées en local.

Par exemple ici, on a ajouté un nouveau fichier: *ProgrammeR.R*. La fenêtre indique que le push a été rejeté: 


::: {.center} 
::: {.box_img}
![](img2/img24.png){width=75%}
:::
:::

Pour effectuer cette récupération des éléments modifiés directement dans le dépôt distant et mettre les deux répertoire sur un même niveau, il faut effectuer un **PULL**: 

* Via l'onglet Git + cliquer sur **PULL**.
* Via la fenêtre commit + cliquer sur **PULL**.
* Via le terminal utiliser la commande **`git pull`**.

Une fois cette opération réalisée, le nouveau programme pourra êtré déposé sur le dépôt distant.

Avec les commandes: 

```{.md filename="récupération des modifications dans le dépôt distant" }
git pull
```


```{.md filename="Ajout d'un fichier dans le dépôt distant "}
git add .
git commit --m "Add ProgrammeR.R"
git push
```


::: callout-important 
L'opération **PULL** ne supprimera pas le fichier ProgrammeR.R créé dans le répertoire local et absent du dépôt distant. Il n'existe pas en distant, donc pas de delta sur ce niveau. La mise à jour ne concernera que la modification du fichier **README.md**.  
Par contre, si on supprime un fichier sur le dépôt distant et qu'il est présent sur le répertoire local, il sera supprimé du local lors du PULL. En cas de regret pas de panique, la suppression aura fait l'objet d'un commit et on pourra donc toujours récupérer cet éléments supprimé.  

Si en local on avait modifié le fichier Readme, à une virgule ou à un espace près, lui même modifié préalablement sur le dépôt distant....CONFLICT.
Et c'est justement ce qu'on va faire dans la section suivante. 

:::

## Conflit et sa résolution

On va générer un conflit très simple sur un fichier readme.md en l'éditant dans un premier temps sur le dépôt distant puis sur le répertoire local, sans avoir effectué un pull.

* Edition sur le dépot distant avec le texte "*Modification du readme dans gitlab*"
  * Application d'un commit
* Edition sur le répertoire local avec le texte "*Modification du readme dans RStudio*"
  * Tentative de pusher cet modification dans le répertoire distant

Résultat: 

* un message d'erreur apparait signalant le rejet du push.


* Si on fait `git pull`: 
  * le fichier readme dans la fenêtre git est tagé en jaune
  * Dans l'éditeur, le fichier est modifié: la première modification dans gitlab est reportée.
  * Il va falloir choisir qu'elle modification on veur apporter au projet.

L'état dans RStudio au moment du conflit  

::: {.center}
::: {box.img}
![Conflit](img2/conflit1.png)
:::
:::



L'ensemble des opérations effectuées:  


::: {.center}
::: {box.img}
![Conflit](img2/video_conflit1.gif)
:::
:::


Dans le fichier readme.md la partie en conflit est balisée et la modification effectuée en amont sur gitlab a été reportée

```{.mf filename="Report du conflit dans le fichier Readme.md }
<<<<<<< HEAD
  Modification du readme dans RStudio
=======
Modification du readme dans gitlab  
>>>>>>> 7c9442d47454d13263230b659af853eeed84afe5

```

**Résolution du conflit**

On va donc devoir choisir entre les deux modifications. Ici on va prendre celle réaliser sur RStudio: 

* On conserve le texte de la modification RStudio
* On supprime les balises

```{.mf}
  Modification du readme dans RStudio
```

* On refait l'opération de transfert du local au distant

::: {.center}
::: {box.img}
![Conflit](img2/video_conflit2.gif)
:::
:::


Et tout rentre dans l'ordre \(^_^)/


Cela va nous amener tout naturellement à parler du travail sur des branches secondaires à la branche principale. 


## Introduction au travail sur les branches






